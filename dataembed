#!/bin/bash
#
# dataembed - Embed encoded binary data files in a shell script
#
#    Copyright (C) 2012 Rodrigo Silva (MestreLion) <linux@rodrigosilva.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program. See <http://www.gnu.org/licenses/gpl.html>
#
# Edit shell scripts, embedding binary data files, base-64 encoded, wrapped
# in a convenient, ready to use function

myname="${0##*/}"
mydir=$(dirname "$(readlink -f "$0")")

#Defaults:
verbose=0
backup=1
inplace=0
ext=".bak"
encode=(-m)
infiles=()
outfile=
function="decode"

# Defaults for eclipse install
#infiles=( "$mydir/eclipse.png" )
#outfile="install"

message() { printf "%s\n" "$1" >&2 ; }
skip()    { message "skipping ${2:-$file}${1:+: $1}"; continue ; }
fatal()   { [[ "$1" ]] && message "$myname: error: $1" ; exit ${2:-1} ; }
argerr()  { printf "%s: %s\n" "$myname" "${1:-error}" >&2 ; usage 1 ; }
invalid() { argerr "invalid option: $1" ; }

usage() {
cat <<- USAGE
Usage: $myname [options] [--output=FILE] [--] [INPUTFILE...]
USAGE
if [[ "$1" ]] ; then
	cat >&2 <<- USAGE
	Try '$myname --help' for more information.
	USAGE
	exit 1
fi
cat <<-USAGE

Embed encoded binary data files in a shell script, wrapped as a function

By default uses sdandard output, but if an output file is provided it is
edited in-place. Default encoding is Base64 unless -M option is used

Options:
  -h|--help        show this page.
  -v|--verbose     print more details (in stderr)

  -M               uses uuencoding instead of Base 64

  --no-backup      disables backup of the output file
  --suffix=SUFFIX  suffix used for backups. Default is "$ext"

  --function=NAME  the name of the function in the wrapper code. Obviously
                   must be a unique function name in the output script.
                   Default is "${function}"

  --output=FILE    output file to embed the encoded data into. If ommited
                   or blank use standard output. Default is "$outfile"

  INPUTFILE...     The file(s) to embed. If no file, reads from standard input
                   Default is "${infiles[@]}"

Output format:

 1: ${function}(){
 2: local name="\$1"
 3: shift
 4: case "\$name" in
 5: "<filename>") uudecode "\$@" <<-'EOF'
 6: <encoded data>
 7: EOF
 8: ;;
 9: *) return 1 ;; # not found
10: esac
11: }

Lines 5-8 are repeated for each input file given. This wrapper code can be
used in the output script as:

${function} "myfile" [-o outfile] || echo "not found"

It can be piped to another command, redirected to a file or used as a
fd like <($function "myfile"). Other usages, like \$($function) subshells or
<<< heredocs, either to a var or a command, is strongly discouraged
since $function() outputs binary data. If "myname" is not found, $function()
has no output and exits with status code 1. Files read from standard
input have a blank "" name.

Only the block between "$function()" and "}" is rewritten in the output file,
and if such block does not exist, the code is it appended to end of file.
A backup is created by default when editing in place.

Copyright (C) 2012 Rodrigo Silva (MestreLion) <linux@rodrigosilva.com>
License: GPLv3 or later. See <http://www.gnu.org/licenses/gpl.html>
USAGE
exit 0
}

# Option handling
for arg in "$@"; do case "$arg" in -h|--help) usage ;; esac; done
while (( $# )); do
	case "$1" in
	-v|--verbose  ) verbose=1         ;;
	-M            ) encode=()         ;;
	--no-backup   ) backup=0          ;;
	--suffix=*    ) suffix="${1#*=}"  ;;
	--output=*    ) outfile="${1#*=}" ;;
	--function=*  ) function="${1#*=}";;
	--            ) shift ; break     ;;
	-*            ) invalid "$1"      ;;
	*             ) infiles+=( "$1" ) ;;
	esac
	shift
done
infiles+=( "$@" )

# if not input files, read from stdin
(( ${#infiles[@]} )) || infiles=("")

# output file, if provided, must exist
[[ "$outfile" ]] && {
	[[ -f "$outfile" ]] || 	argerr "'$outfile' is not a valid file"
}

# functtion names must have only letters, digits and "_"
[[ "$function" == [[:alnum:]_-]+ ]] &&
	argerr "'$function' is not a valid function name"

# If user supplied extension is blank, use default
ext=${suffix:-$ext}

regex="^[[:blank:]]*${function}[[:blank:]]*()"

if [[ "$outfile" ]] ; then
	# create tempfile
	tmpfile=$(tempfile -d $(dirname "$outfile")) ||
		fatal "could not create temporary file"
	trap 'rm -f -- "$tmpfile"' EXIT
	exec 3>"$tmpfile"

	# print script until function
	awk -v regex="$regex" '$0 ~ regex {exit}1' "$outfile" >&3
else
	# no output file, use stdout
	exec 3>&1
fi

# Do the magic :)

# Header
cat >&3 <<-EOF
	decode(){
	local name="\$1"
	shift
	case "\$name" in
EOF

# Loop of input files
for file in "${infiles[@]}"; do

	[[ "$file" ]] || file=() # hack for uuencode to read stdin
	name=$(basename "$file") # don't save paths

	cat >&3 <<-FOE
		"$name") uudecode "\$@" <<-'EOF'
	FOE

	# actual encoder
	uuencode "${encode[@]}" "${file[@]}" "${name}" >&3 || skip

	cat >&3 <<-FOE
		EOF
		;;
	FOE

	((verbose)) && message "embedded ${file[@]} in ${outfile}"
done

# Footer
cat >&3 <<-EOF
	*) return 1 ;; # not found
	esac
	}
EOF

# print the rest of file
[[ "$outfile" ]] &&
awk -v regex="$regex" '
	after {print;next}
	block && /^[[:blank:]]*\}/ {after=1;next}
	!block && $0 ~ regex       {block=1}
' "$outfile" >&3

# Close tempfile, backup original, update output file
exec 3>&-
[[ "$outfile" ]] && ((backup)) &&
cp "$outfile" "$outfile$ext" &&
cat "$tmpfile" > "$outfile"
